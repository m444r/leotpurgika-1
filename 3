#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MEMORY_SIZE 512
#define TIME_QUANTUM 3
#define MAX_PROCESSES 5

typedef struct {
    int pid;
    int arrival_time;
    int duration;
    int remaining_time;
    int memory_needed;
    bool in_memory;
} Process;

typedef struct {
    int start;
    int size;
    bool free;
    int pid;
} MemoryBlock;

MemoryBlock memory[MEMORY_SIZE];
Process processes[MAX_PROCESSES];
int process_count = 0;
int current_time = 0;

void initialize_memory() {
    memory[0].start = 0;
    memory[0].size = MEMORY_SIZE;
    memory[0].free = true;
    memory[0].pid = -1;
}

void get_process_input() {
    printf("Enter process details for up to %d processes:\n", MAX_PROCESSES);
    for (int i = 0; i < MAX_PROCESSES; i++) {
        int arrival_time, duration, memory_needed;
        printf("\nProcess %d:\n", i + 1);
        printf("Arrival Time (ms): ");
        scanf("%d", &arrival_time);
        printf("Duration (ms): ");
        scanf("%d", &duration);
        printf("Memory Needed (KB): ");
        scanf("%d", &memory_needed);

        if (memory_needed <= 0 || duration <= 0) {
            printf("Error: Memory and duration must be positive values.\n");
            exit(EXIT_FAILURE);
        }

        processes[i].pid = i;
        processes[i].arrival_time = arrival_time;
        processes[i].duration = duration;
        processes[i].remaining_time = duration;
        processes[i].memory_needed = memory_needed;
        processes[i].in_memory = false;
        process_count++;
    }
}

bool allocate_memory(int pid, int memory_needed) {
    for (int i = 0; i < MEMORY_SIZE; i++) {
        if (memory[i].free && memory[i].size >= memory_needed) {
            if (memory[i].size > memory_needed) {
                for (int j = MEMORY_SIZE - 1; j > i; j--) {
                    memory[j] = memory[j - 1];
                }
                memory[i + 1].start = memory[i].start + memory_needed;
                memory[i + 1].size = memory[i].size - memory_needed;
                memory[i + 1].free = true;
                memory[i + 1].pid = -1;
                memory[i].size = memory_needed;
            }
            memory[i].free = false;
            memory[i].pid = pid;
            return true;
        }
    }
    return false;
}

void deallocate_memory(int pid) {
    for (int i = 0; i < MEMORY_SIZE; i++) {
        if (memory[i].pid == pid) {
            memory[i].free = true;
            memory[i].pid = -1;
            if (i > 0 && memory[i - 1].free) {
                memory[i - 1].size += memory[i].size;
                for (int j = i; j < MEMORY_SIZE - 1; j++) {
                    memory[j] = memory[j + 1];
                }
                i--;
            }
            if (i < MEMORY_SIZE - 1 && memory[i + 1].free) {
                memory[i].size += memory[i + 1].size;
                for (int j = i + 1; j < MEMORY_SIZE - 1; j++) {
                    memory[j] = memory[j + 1];
                }
            }
        }
    }
}

void simulate() {
    int time_slice = 0;
    int running_process = -1;
    while (1) {
        bool all_done = true;
        for (int i = 0; i < process_count; i++) {
            if (processes[i].remaining_time > 0) {
                all_done = false;
                if (processes[i].arrival_time <= current_time && !processes[i].in_memory) {
                    if (allocate_memory(processes[i].pid, processes[i].memory_needed)) {
                        processes[i].in_memory = true;
                        printf("Time %d: Process %d loaded into memory.\n", current_time, processes[i].pid);
                    }
                }
            }
        }

        if (all_done) break;

        if (running_process == -1 || time_slice == 0) {
            for (int i = 0; i < process_count; i++) {
                if (processes[i].remaining_time > 0 && processes[i].in_memory) {
                    running_process = i;
                    time_slice = TIME_QUANTUM;
                    break;
                }
            }
        }

        if (running_process != -1) {
            printf("Time %d: Process %d is running.\n", current_time, processes[running_process].pid);
            processes[running_process].remaining_time--;
            time_slice--;

            if (processes[running_process].remaining_time == 0) {
                printf("Time %d: Process %d finished execution.\n", current_time, processes[running_process].pid);
                deallocate_memory(processes[running_process].pid);
                processes[running_process].in_memory = false;
                running_process = -1;
                time_slice = 0;
            }
        }

        current_time++;
    }
}

int main() {
    initialize_memory();
    get_process_input();
    simulate();
    return 0;
}
